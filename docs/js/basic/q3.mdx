# #3 ES 每个版本引入了什么内容？

:::info ES是什么？
ES 是 ECMAScript 的缩写，指的是由 ECMA 国际（ECMA International）标准化的脚本编程语言规范。ECMAScript 是 JavaScript 的标准规范，最初由 Netscape 和 Sun Microsystems（现属于 Oracle）在 1997 年提交给 ECMA，以标准化 JavaScript 的发展方向。
:::

### 主要的ECMAScript版本

#### **ES3(1999年)**：对 JavaScript 的早期特性进行标准化，使之成为一个相对成熟的语言。

#### **ES5(2009年)**

增加了严格模式（strict mode）、JSON 支持、Array 的高级方法（如 map、forEach）等功能。

#### **ES6 / ES2015(ECMAScript 2015年)**

一个里程碑式的版本:

- 引入了`let`和`const`关键字，用于声明块级作用域的变量。
- 引入箭头函数
- 引入模板字符串
- 解构赋值
- 引入类和模块
- 引入Promise

:::info 提示：
在 ES6 之后，ECMA 国际决定采用年份来命名版本（如 ES2016、ES2017），每年发布一次更新，确保 JavaScript 语言在开发需求中不断演进。
:::

#### **ES7 / ES2016**

ES7（即 ECMAScript 2016）是一个相对较小的更新版本，但它引入了两个实用的新特性

- 引入了`Array.prototype.includes()`方法，用于检查数组是否包含特定元素。
- 引入了一个新的指数运算符`**`,用于取幂操作，功能与`Math.pow()`相同，但语法更简洁。

```javascript
console.log(2 ** 3);   //输出8， 相当于Math.pow(2, 3);
console.log(5 ** 2);   //输出25，相当于Math.pow(5, 2);
```

#### **ES8 / ES2017**

ES8（即 ECMAScript 2017）引入了一些实用的新特性，增强了 JavaScript 的功能。

- 引入`async`和`await`
- 引入`Object.entries()`和`Object.values()`
- 字符串补全方法`String.prototype.padStart()`和`String.prototype.padEnd()`这两个方法用于在字符串的开始或结束添加填充字符，直到达到指定的长度。
- `Object.getOwnPropertyDescriptors()`：此方法返回一个对象自身所有属性的描述符对象，这些属性包括可枚举和不可枚举的。

#### **ES9 / ES2018**

- 引入了异步迭代器（for await...of）
- 引入对象的扩展运算符（...）
- 引入`Promise.prototype.finally()`：为 Promise 提供了一种处理无论 Promise 成功还是失败后都要执行的回调函数的方式。

#### **ES10 / ES2019**

- 引入了`Array.prototype.flat()` 和 `Array.prototype.flatMap()` 方法，用于处理嵌套数组。
  - flat() 方法用于将嵌套数组展开到指定深度。
  - flatMap() 方法先对数组中的每个元素执行映射操作，然后将结果展开。
```javascript

const arr = [1, 2, [3, 4]];
console.log(arr.flat()); // 输出 [1, 2, 3, 4]

const arr2 = [1, 2, 3];
console.log(arr2.flatMap(x => [x, x * 2])); // 输出 [1, 2, 2, 4, 3, 6]

```

- 引入了`Object.fromEntries()`：将一个键值对数组转换为对象，类似于 Object.entries() 的反向操作。

```javascript
const entries = [['foo', 'bar'], ['baz', 42]];
const obj = Object.fromEntries(entries);
console.log(obj); // 输出 { foo: 'bar', baz: 42 }
```

- 引入了`String.prototype.trimStart()`和`String.prototype.trimEnd()`:新增了去除字符串开头和结尾空格的方法，分别为 trimStart() 和 trimEnd()。

- Optional Catch Binding：在 try...catch 语句中，可以省略 catch 子句中的绑定变量，适用于只需要执行 catch 语句而不需要处理错误时的场景。

```javascript
try {
  // 代码块
} catch {
  console.log('出错了，但不关心具体错误');
}
```

#### **ES11 / ES2020**

- 引入了可选链操作符`?.`（optional chaining Operator）：允许安全地访问深层次属性，避免因访问不存在的属性而抛出错误。

```javascript
const user = { name: 'Alice', address: { city: 'Wonderland' } };
console.log(user.address?.city); // 输出 'Wonderland'
console.log(user.contact?.phone); // 输出 undefined
```

- 引入了空值合并运算符`??`(Nullish Coalescing Operator)：提供了一个新的逻辑运算符，用于在操作数为 null 或 undefined 时返回右侧操作数。
```javascript
const foo = null ?? 'default string';
console.log(foo); // 输出 'default string'

const bar = 0 ?? 42;
console.log(bar); // 输出 0，因为 0 不是 null 或 undefined
```
- 引入了`BigInt`类型，新增了一种新的数据类型，用于表示任意大小的整数和处理超出`Number`类型范围的整数,

- 引入了动态导入`Dynamic Import`：支持动态导入模块，允许在运行时加载模块。

```javascript
async function loadModule() {
  const module = await import('./module.js');
  module.doSomething();
}
```

- 引入`Promise.allSettled()`

返回一个 Promise，当所有给定的 Promise 都已完成（不论是成功还是失败）时，会返回一个包含每个 Promise 的结果的数组。

```javascript
const promises = [
  Promise.resolve(1),
  Promise.reject('error'),
  Promise.resolve(3)
];

Promise.allSettled(promises).then(results => {
  console.log(results);
  // 输出 [{ status: 'fulfilled', value: 1 }, { status: 'rejected', reason: 'error' }, { status: 'fulfilled', value: 3 }]
});
```

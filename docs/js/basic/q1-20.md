# 基础部分（#1-#20）

## #1 JS的数据类型

JavaScript 有8种数据类型

- 值类型（基本类型）：

  1. **Number（数字）**：表示数值

        - 整数、浮点数

        - 特殊值(Infinity) 和 (-Infinity)：表示正无穷和负无穷，通常在除以 0 或超出 Number 的表示范围时出现。

        - NaN（Not-a-Number）：表示“不是数字”，在试图进行非法数学操作（如 0 / 0 或 Math.sqrt(-1)）时出现。

        - 进制数：
          - 十六进制：以`0x`或`0X`开头的数字
          - 二进制：以`0b`或`0B`开头的数字（^ES6+）
          - 八进制：以`0o`或`0O`开头的数字（^ES6+）

  2. **String（字符串）**：表示多字符数据，使用引号(单引号或双引号)括起来。
  3. **Boolean（布尔值）**：表示真（true）或false（假）。
  4. **Null（空）**：表示一个空值或没有值的对象。
  5. **Undefined（未定义）**：表示一个未被赋值的变量的值。
  6. **Symbol（符号）**

        Symbol 是 **ECMAScript 2015 (ES6)** 引入了一种新的原始数据类型，表示独一无二的值。

  7. **BigInt（大整数）**

        在 **ECMAScript 2020 (ES11)** 规范中正式被添加BigInt数据类型。于对“大整数”的表示和操作。

        结尾用n表示：例如 1024n

- 引用数据类型：

  8. **Object（对象）**
       - 数组（Array）
       - 函数（Function）
       - 正则（RegExp）
       - 日期（Date）
       - Map和WeakMap
       - Set和WeakSet
       - Promise
       - 等等

## #2 如何判断JS的数据类型？

### 1. `typeof`操作符

`typeof`是最常用的方式之一，可以返回一个值的基本类型。适用于区分原始类型（如 string、number 等）和 function 类型。

```javascript

console.log(typeof "hello");        // "string"
console.log(typeof 42);             // "number"
console.log(typeof true);           // "boolean"
console.log(typeof undefined);      // "undefined"
console.log(typeof Symbol());       // "symbol"
console.log(typeof null);           // "object"
console.log(typeof {});             // "object"
console.log(typeof []);             // "object"
console.log(typeof function(){})    // "function"

```

> 注意：typeof null 返回 "object"，这是 JavaScript 的一个历史遗留问题，并不意味着 null 是对象。

### 2. `instanceof`操作符

instanceof 用于判断一个对象是否是某个构造函数的实例，通常用于检查复杂数据类型，比如数组和自定义对象。

```javascript

console.log([] instanceof Array);               // true
console.log({} instanceof Object);              // true
console.log(new Date() instanceof Date);        // true
console.log(function(){} instanceof Function);  // true
console.log(null instanceof Object);            // false (null 不是 Object 的实例)
console.log(undefined instanceof Object);       // false (undefined 不是 Object 的实例)

```

### 3. `constructor`

每个对象实例都有一个 constructor 属性，指向创建该对象的构造函数，可以用来判断对象类型。

```javascript

console.log((5).constructor === Number);      // true
console.log("hello".constructor === String);  // true
console.log([].constructor === Array);        // true
console.log({}.constructor === Object);       // true
console.log(new Date().constructor === Date); // true

```

### 4. `Object.prototype.toString.call()`

toString()是 Object 的原型方法，调用该方法，默认返回当前对象的 [object type]。其中 type 就是对象的类型。

```javascript

console.log(Object.prototype.toString.call("hello"));       // "[object String]"
console.log(Object.prototype.toString.call(42));            // "[object Number]"
console.log(Object.prototype.toString.call([]));            // "[object Array]"
console.log(Object.prototype.toString.call({}));            // "[object Object]"
console.log(Object.prototype.toString.call(null));          // "[object Null]"
console.log(Object.prototype.toString.call(undefined));     // "[object Undefined]"
console.log(Object.prototype.toString.call(new Date()));    // "[object Date]"
console.log(Object.prototype.toString.call(/regex/));       // "[object RegExp]"


```

### 5. 一些类自带的判断方法

`Array.isArray()`：Array.isArray() 专门用于检查一个值是否是数组，是检测数组的推荐方式。

```javascript

console.log(Array.isArray([]));       // true
console.log(Array.isArray({}));       // false

```

## #3 ES 每个版本引入了什么内容？

:::info ES是什么？
ES 是 ECMAScript 的缩写，指的是由 ECMA 国际（ECMA International）标准化的脚本编程语言规范。ECMAScript 是 JavaScript 的标准规范，最初由 Netscape 和 Sun Microsystems（现属于 Oracle）在 1997 年提交给 ECMA，以标准化 JavaScript 的发展方向。
:::

### 主要的ECMAScript版本

#### **ES3(1999年)**：对 JavaScript 的早期特性进行标准化，使之成为一个相对成熟的语言。

#### **ES5(2009年)**

增加了严格模式（strict mode）、JSON 支持、Array 的高级方法（如 map、forEach）等功能。

#### **ES6 / ES2015(ECMAScript 2015年)**

一个里程碑式的版本:

- 引入了`let`和`const`关键字，用于声明块级作用域的变量。
- 引入箭头函数
- 引入模板字符串
- 解构赋值
- 引入类和模块
- 引入Promise

:::info 提示：
在 ES6 之后，ECMA 国际决定采用年份来命名版本（如 ES2016、ES2017），每年发布一次更新，确保 JavaScript 语言在开发需求中不断演进。
:::

#### **ES7 / ES2016**

ES7（即 ECMAScript 2016）是一个相对较小的更新版本，但它引入了两个实用的新特性

- 引入了`Array.prototype.includes()`方法，用于检查数组是否包含特定元素。
- 引入了一个新的指数运算符`**`,用于取幂操作，功能与`Math.pow()`相同，但语法更简洁。

```javascript
console.log(2 ** 3);   //输出8， 相当于Math.pow(2, 3);
console.log(5 ** 2);   //输出25，相当于Math.pow(5, 2);
```

#### **ES8 / ES2017**

ES8（即 ECMAScript 2017）引入了一些实用的新特性，增强了 JavaScript 的功能。

- 引入`async`和`await`
- 引入`Object.entries()`和`Object.values()`
- 字符串补全方法`String.prototype.padStart()`和`String.prototype.padEnd()`这两个方法用于在字符串的开始或结束添加填充字符，直到达到指定的长度。
- `Object.getOwnPropertyDescriptors()`：此方法返回一个对象自身所有属性的描述符对象，这些属性包括可枚举和不可枚举的。

#### **ES9 / ES2018**

- 引入了异步迭代器（for await...of）
- 引入对象的扩展运算符（...）
- 引入`Promise.prototype.finally()`：为 Promise 提供了一种处理无论 Promise 成功还是失败后都要执行的回调函数的方式。

#### **ES10 / ES2019**

- 引入了`Array.prototype.flat()` 和 `Array.prototype.flatMap()` 方法，用于处理嵌套数组。
  - flat() 方法用于将嵌套数组展开到指定深度。
  - flatMap() 方法先对数组中的每个元素执行映射操作，然后将结果展开。
```javascript

const arr = [1, 2, [3, 4]];
console.log(arr.flat()); // 输出 [1, 2, 3, 4]

const arr2 = [1, 2, 3];
console.log(arr2.flatMap(x => [x, x * 2])); // 输出 [1, 2, 2, 4, 3, 6]

```

- 引入了`Object.fromEntries()`：将一个键值对数组转换为对象，类似于 Object.entries() 的反向操作。

```javascript
const entries = [['foo', 'bar'], ['baz', 42]];
const obj = Object.fromEntries(entries);
console.log(obj); // 输出 { foo: 'bar', baz: 42 }
```

- 引入了`String.prototype.trimStart()`和`String.prototype.trimEnd()`:新增了去除字符串开头和结尾空格的方法，分别为 trimStart() 和 trimEnd()。

- Optional Catch Binding：在 try...catch 语句中，可以省略 catch 子句中的绑定变量，适用于只需要执行 catch 语句而不需要处理错误时的场景。

```javascript
try {
  // 代码块
} catch {
  console.log('出错了，但不关心具体错误');
}
```

#### **ES11 / ES2020**

- 引入了可选链操作符`?.`（optional chaining Operator）：允许安全地访问深层次属性，避免因访问不存在的属性而抛出错误。

```javascript
const user = { name: 'Alice', address: { city: 'Wonderland' } };
console.log(user.address?.city); // 输出 'Wonderland'
console.log(user.contact?.phone); // 输出 undefined
```

- 引入了空值合并运算符`??`(Nullish Coalescing Operator)：提供了一个新的逻辑运算符，用于在操作数为 null 或 undefined 时返回右侧操作数。
```javascript
const foo = null ?? 'default string';
console.log(foo); // 输出 'default string'

const bar = 0 ?? 42;
console.log(bar); // 输出 0，因为 0 不是 null 或 undefined
```
- 引入了`BigInt`类型，新增了一种新的数据类型，用于表示任意大小的整数和处理超出`Number`类型范围的整数,

- 引入了动态导入`Dynamic Import`：支持动态导入模块，允许在运行时加载模块。

```javascript
async function loadModule() {
  const module = await import('./module.js');
  module.doSomething();
}
```

- 引入`Promise.allSettled()`

返回一个 Promise，当所有给定的 Promise 都已完成（不论是成功还是失败）时，会返回一个包含每个 Promise 的结果的数组。

```javascript
const promises = [
  Promise.resolve(1),
  Promise.reject('error'),
  Promise.resolve(3)
];

Promise.allSettled(promises).then(results => {
  console.log(results);
  // 输出 [{ status: 'fulfilled', value: 1 }, { status: 'rejected', reason: 'error' }, { status: 'fulfilled', value: 3 }]
});
```

## #4 == 和 === 的区别

JavaScript 提供三种不同的值比较运算：
- === 严格相等（三个等号）
- == 宽松相等（两个等号）
- Object.is()

`==`叫做相等运算符，`===`叫做严格运算符。

### 规则

1. `==`：先隐式类型转换，再判断值是否相等

2. `===`：直接判断 类型 + 值 是否相等

3. `==`表示只要值相等即可为真，而`===`则要求不仅值相等，而且也要求类型相同。

### `==`

```javascript
5 == '5'                          // true，因为字符串 '5' 被转换为数字 5
'' == '0'                         // false
0 == ''                           // true
0 == '0'                          // true
false == 'false'                  // false
false == '0'                      // true
false == undefined                // false
false == null                     // false
null == undefined                 // true
' \t\r\n ' == 0                   // true
```
嗯,很奇妙的`==`，给我带来了一些反直觉的结果

### `===`

```javascript
console.log(1 === "1");           //false, 类型不同
console.log(true === 1);          //false, 类型不同
console.log(null === undefined);  // false，因为类型不同
```
nice，和符合我们直觉的结果

所以说：一般推荐在 JavaScript 中优先使用 `===`，以避免潜在的错误，而且很符合我们的直觉何乐而不为呢？

### 补充 Object.is()

:::info Object.is()
Object.is() 是一个用于比较两个值是否相同的方法，它在某些情况下比 === 更准确。以下是 Object.is() 的主要特点和用法：

```javascript
Object.is(value1, value2);
```
特点：
1. 类型和值完全相等：Object.is() 会考虑值的类型，并且只有在两个值相等时才返回 true。
2. 特殊情况
  - `NaN`被视为相等
    ```javascript
    console.log(Object.is(NaN, NaN)) // true 注意： === 是false
    ```
  - `+0` 和 `-0`被视为不想等
    ```javascript
    console.log(Object.is(+0, -0)); //false 注意： === 是相等
    ```

与 `===` 的比较
Object.is() 更严格，它处理一些 `===` 不处理的特殊情况。
对于一般的比较，=== 更加常用，但在需要处理 NaN 和 +0/-0 的情况下，Object.is() 更加可靠。

当需要精确比较对象、数组或者处理特殊值时，使用 Object.is() 是一个很好的选择。

总的来说，Object.is() 提供了一种更精确的方式来比较值，特别是在处理 JavaScript 中的一些特殊情况时。

:::

> 参考：
>
> [相等比较和相同 MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness)


## #5 String 的 startsWith 和 indexOf两种方法的区别

- **startsWith**

1. 用于判断字符串是否以指定的子字符串开头。
2. 返回值：`true`或者`false`

- **indexOf**

1. 返回值：子字符串的起始索引位置（如果找到），否则返回`1`
2. 可以接受两个参数，第一个参数是要查找的子字符串，第二个参数是可选的，示开始搜索的位置。

```javascript
const str = "Hello, world!";
console.log(str.indexOf("Hello")); // 0
console.log(str.indexOf("world", 7)) // 7(从索引7开始查找)
```
### 兼容性

- startsWith 是 ES6 引入的，可能不在旧版浏览器中支持。
- indexOf 在所有 JavaScript 环境中都兼容。

## 🔥#6 bind, apply, call 的区别

共性：`bind`、`apply` 和 `call` 是 JavaScript 中用于改变函数上下文 (`this` 指向)的方法。虽然它们的作用类似，但使用场景和行为上有所不同。

- `bind`: 返回一个新的函数，该函数的 this 被永久绑定到指定的对象，且可以接收预设参数。调用时不会立即执行，而是返回一个绑定后的函数。

- `call`：直接调用函数，并且 this 指向指定的对象，参数是逐个传入。

- `apply`: 直接调用函数，this 指向指定的对象，参数以数组形式传入。

```javascript
function greet(greeting, punctuation) {
    console.log(`${greeting}, ${this.name}${punctuation}`);
}

const person = { name: "Alice" };

const boundGreet = greet.bind(person, "Hello"); // 不会立即执行
boundGreet("!");

greet.call(person, "Hello", "!");

greet.apply(person, ["Hello", "!"]);

```
### 用法对比
| 方法 | 是否立即执行 |参数形式 |	返回值|
| ----- | ---- | ---- | ---- |
| bind  |	 否	 | 单独列出或部分传参 |	返回绑定后的新函数 |
| call  |  是	 | 单独列出参数      | 执行并返回函数结果 |
| apply |	 是	 | 数组形式的参数     |   执行并返回函数结果 |

### 实现

- `bind`

```javascript

Function.prototype.myBind = function(context, ...args) {
  const func = this;
  return function(...newArgs) {
    return func.apply(context, args.concat(newArgs));
  }
}

```

- `apply`

```javascript

Function.prototype.myApply = function(context, args) {
  context = context || window
  const fn = Symbol();
  context[fn] = this;
  const result = context[fn](...args);
  delete context[fn]
  return result;
}

```

- `call`

```javascript

Function.prototype.myCall = function(context, ...args) {
  context = context || window;      // 如果没有传入上下文，则默认为全局对象
  const uniqueID = Symbol();        // 创建唯一键，以免属性名冲突
  context[uniqueID] = this;         // 在上下文中添加一个属性，将函数赋值给这个属性
  const result = context[uniqueID](...args); // 调用函数
  delete context[uniqueID]; // 删除新增加的属性
  return result; //返回结果
}

```
### 实际例子

1. `bind` 实际应用：事件处理中的 this 绑定
在事件处理函数中，this 默认指向触发事件的元素，但有时需要绑定到特定对象，比如组件实例。

```javascript
const user = {
  name: "Alice",
  age: 25,
  logInfo() {
    console.log(`Name: ${this.name}, Age: ${this.age}`);
  }
};

// 使用 bind 创建绑定后的函数
const button = document.querySelector("button");
button.addEventListener("click", user.logInfo.bind(user)); // 输出: Name: Alice, Age: 25
```

在这个例子中，如果直接传 user.logInfo，this 会指向 button 元素。

而 `bind` 将 `this` 绑定到 user，因此点击按钮时 logInfo 输出的 name 和 age 就是 user 的信息。

2. `call` 实际应用：对象继承方法的复用
call 可以用来在一个对象上调用另一个对象的方法，从而实现方法的复用。例如，多个对象有相同结构时，可以复用代码。

```javascript
const person1 = { name: "Alice" };
const person2 = { name: "Bob" };

function sayHello(greeting) {
  console.log(`${greeting}, ${this.name}`);
}

// 使用 call 复用 sayHello 方法
sayHello.call(person1, "Hello"); // 输出: "Hello, Alice"
sayHello.call(person2, "Hi");    // 输出: "Hi, Bob"
```

在这里，`sayHello` 使用 `call` 指向不同对象，从而复用相同的方法。

3. `apply` 实际应用：计算数组的最大/最小值

`apply` 常用于将数组传递给参数数量不固定的函数，例如 Math.max 或 Math.min。这样可以直接求一个数组的最大值或最小值。

```javascript
const numbers = [5, 2, 9, 3, 7];

const max = Math.max.apply(null, numbers);
const min = Math.min.apply(null, numbers);

console.log(`Max: ${max}, Min: ${min}`); // 输出: Max: 9, Min: 2
```
这里通过 `apply` 把 numbers 数组传入 Math.max 和 Math.min 函数中，求出最大和最小值。

apply 将数组元素分别作为参数传递给函数，这是 call 无法做到的。

4. `bind` 实际应用：预设函数参数

bind 可以预设函数的部分参数，生成一个带有固定参数的新函数（类似“部分应用”）。

```javascript
function multiply(a, b) {
  return a * b;
}

const double = multiply.bind(null, 2); // 固定第一个参数 a = 2
console.log(double(5)); // 输出: 10 (2 * 5)

const triple = multiply.bind(null, 3); // 固定第一个参数 a = 3
console.log(triple(5)); // 输出: 15 (3 * 5)

```

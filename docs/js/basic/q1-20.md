# 基础部分（#1-#20）

## #1 JS的数据类型

JavaScript 有8种数据类型

- 值类型（基本类型）：

  1. **Number（数字）**：表示数值

        - 整数、浮点数

        - 特殊值(Infinity) 和 (-Infinity)：表示正无穷和负无穷，通常在除以 0 或超出 Number 的表示范围时出现。

        - NaN（Not-a-Number）：表示“不是数字”，在试图进行非法数学操作（如 0 / 0 或 Math.sqrt(-1)）时出现。

        - 进制数：
          - 十六进制：以`0x`或`0X`开头的数字
          - 二进制：以`0b`或`0B`开头的数字（^ES6+）
          - 八进制：以`0o`或`0O`开头的数字（^ES6+）

  2. **String（字符串）**：表示多字符数据，使用引号(单引号或双引号)括起来。
  3. **Boolean（布尔值）**：表示真（true）或false（假）。
  4. **Null（空）**：表示一个空值或没有值的对象。
  5. **Undefined（未定义）**：表示一个未被赋值的变量的值。
  6. **Symbol（符号）**

        Symbol 是 **ECMAScript 2015 (ES6)** 引入了一种新的原始数据类型，表示独一无二的值。

  7. **BigInt（大整数）**

        在 **ECMAScript 2020 (ES11)** 规范中正式被添加BigInt数据类型。于对“大整数”的表示和操作。

        结尾用n表示：例如 1024n

- 引用数据类型：

  8. **Object（对象）**
       - 数组（Array）
       - 函数（Function）
       - 正则（RegExp）
       - 日期（Date）
       - Map和WeakMap
       - Set和WeakSet
       - Promise
       - 等等

## #2 如何判断JS的数据类型？

### 1. `typeof`操作符

`typeof`是最常用的方式之一，可以返回一个值的基本类型。适用于区分原始类型（如 string、number 等）和 function 类型。

```javascript

console.log(typeof "hello");        // "string"
console.log(typeof 42);             // "number"
console.log(typeof true);           // "boolean"
console.log(typeof undefined);      // "undefined"
console.log(typeof Symbol());       // "symbol"
console.log(typeof null);           // "object"
console.log(typeof {});             // "object"
console.log(typeof []);             // "object"
console.log(typeof function(){})    // "function"

```

> 注意：typeof null 返回 "object"，这是 JavaScript 的一个历史遗留问题，并不意味着 null 是对象。

### 2. `instanceof`操作符

instanceof 用于判断一个对象是否是某个构造函数的实例，通常用于检查复杂数据类型，比如数组和自定义对象。

```javascript

console.log([] instanceof Array);               // true
console.log({} instanceof Object);              // true
console.log(new Date() instanceof Date);        // true
console.log(function(){} instanceof Function);  // true
console.log(null instanceof Object);            // false (null 不是 Object 的实例)
console.log(undefined instanceof Object);       // false (undefined 不是 Object 的实例)

```

### 3. `constructor`

每个对象实例都有一个 constructor 属性，指向创建该对象的构造函数，可以用来判断对象类型。

```javascript

console.log((5).constructor === Number);      // true
console.log("hello".constructor === String);  // true
console.log([].constructor === Array);        // true
console.log({}.constructor === Object);       // true
console.log(new Date().constructor === Date); // true

```

### 4. `Object.prototype.toString.call()`

toString()是 Object 的原型方法，调用该方法，默认返回当前对象的 [object type]。其中 type 就是对象的类型。

```javascript

console.log(Object.prototype.toString.call("hello"));       // "[object String]"
console.log(Object.prototype.toString.call(42));            // "[object Number]"
console.log(Object.prototype.toString.call([]));            // "[object Array]"
console.log(Object.prototype.toString.call({}));            // "[object Object]"
console.log(Object.prototype.toString.call(null));          // "[object Null]"
console.log(Object.prototype.toString.call(undefined));     // "[object Undefined]"
console.log(Object.prototype.toString.call(new Date()));    // "[object Date]"
console.log(Object.prototype.toString.call(/regex/));       // "[object RegExp]"


```

### 5. 一些类自带的判断方法

`Array.isArray()`：Array.isArray() 专门用于检查一个值是否是数组，是检测数组的推荐方式。

```javascript

console.log(Array.isArray([]));       // true
console.log(Array.isArray({}));       // false

```

## #3 ES 每个版本引入了什么内容？

:::info ES是什么？
ES 是 ECMAScript 的缩写，指的是由 ECMA 国际（ECMA International）标准化的脚本编程语言规范。ECMAScript 是 JavaScript 的标准规范，最初由 Netscape 和 Sun Microsystems（现属于 Oracle）在 1997 年提交给 ECMA，以标准化 JavaScript 的发展方向。
:::

### 主要的ECMAScript版本

#### **ES3(1999年)**：对 JavaScript 的早期特性进行标准化，使之成为一个相对成熟的语言。

#### **ES5(2009年)**

增加了严格模式（strict mode）、JSON 支持、Array 的高级方法（如 map、forEach）等功能。

#### **ES6 / ES2015(ECMAScript 2015年)**

一个里程碑式的版本:

- 引入了`let`和`const`关键字，用于声明块级作用域的变量。
- 引入箭头函数
- 引入模板字符串
- 解构赋值
- 引入类和模块
- 引入Promise

:::info 提示：
在 ES6 之后，ECMA 国际决定采用年份来命名版本（如 ES2016、ES2017），每年发布一次更新，确保 JavaScript 语言在开发需求中不断演进。
:::

#### **ES7 / ES2016**

ES7（即 ECMAScript 2016）是一个相对较小的更新版本，但它引入了两个实用的新特性

- 引入了`Array.prototype.includes()`方法，用于检查数组是否包含特定元素。
- 引入了一个新的指数运算符`**`,用于取幂操作，功能与`Math.pow()`相同，但语法更简洁。

```javascript
console.log(2 ** 3);   //输出8， 相当于Math.pow(2, 3);
console.log(5 ** 2);   //输出25，相当于Math.pow(5, 2);
```

#### **ES8 / ES2017**

ES8（即 ECMAScript 2017）引入了一些实用的新特性，增强了 JavaScript 的功能。

- 引入`async`和`await`
- 引入`Object.entries()`和`Object.values()`
- 字符串补全方法`String.prototype.padStart()`和`String.prototype.padEnd()`这两个方法用于在字符串的开始或结束添加填充字符，直到达到指定的长度。
- `Object.getOwnPropertyDescriptors()`：此方法返回一个对象自身所有属性的描述符对象，这些属性包括可枚举和不可枚举的。

#### **ES9 / ES2018**

- 引入了异步迭代器（for await...of）
- 引入对象的扩展运算符（...）
- 引入`Promise.prototype.finally()`：为 Promise 提供了一种处理无论 Promise 成功还是失败后都要执行的回调函数的方式。

#### **ES10 / ES2019**

- 引入了`Array.prototype.flat()` 和 `Array.prototype.flatMap()` 方法，用于处理嵌套数组。
  - flat() 方法用于将嵌套数组展开到指定深度。
  - flatMap() 方法先对数组中的每个元素执行映射操作，然后将结果展开。
```javascript

const arr = [1, 2, [3, 4]];
console.log(arr.flat()); // 输出 [1, 2, 3, 4]

const arr2 = [1, 2, 3];
console.log(arr2.flatMap(x => [x, x * 2])); // 输出 [1, 2, 2, 4, 3, 6]

```

- 引入了`Object.fromEntries()`：将一个键值对数组转换为对象，类似于 Object.entries() 的反向操作。

```javascript
const entries = [['foo', 'bar'], ['baz', 42]];
const obj = Object.fromEntries(entries);
console.log(obj); // 输出 { foo: 'bar', baz: 42 }
```

- 引入了`String.prototype.trimStart()`和`String.prototype.trimEnd()`:新增了去除字符串开头和结尾空格的方法，分别为 trimStart() 和 trimEnd()。

- Optional Catch Binding：在 try...catch 语句中，可以省略 catch 子句中的绑定变量，适用于只需要执行 catch 语句而不需要处理错误时的场景。

```javascript
try {
  // 代码块
} catch {
  console.log('出错了，但不关心具体错误');
}
```

#### **ES11 / ES2020**

- 引入了可选链操作符`?.`（optional chaining Operator）：允许安全地访问深层次属性，避免因访问不存在的属性而抛出错误。

```javascript
const user = { name: 'Alice', address: { city: 'Wonderland' } };
console.log(user.address?.city); // 输出 'Wonderland'
console.log(user.contact?.phone); // 输出 undefined
```

- 引入了空值合并运算符`??`(Nullish Coalescing Operator)：提供了一个新的逻辑运算符，用于在操作数为 null 或 undefined 时返回右侧操作数。
```javascript
const foo = null ?? 'default string';
console.log(foo); // 输出 'default string'

const bar = 0 ?? 42;
console.log(bar); // 输出 0，因为 0 不是 null 或 undefined
```
- 引入了`BigInt`类型，新增了一种新的数据类型，用于表示任意大小的整数和处理超出`Number`类型范围的整数,

- 引入了动态导入`Dynamic Import`：支持动态导入模块，允许在运行时加载模块。

```javascript
async function loadModule() {
  const module = await import('./module.js');
  module.doSomething();
}
```

- 引入`Promise.allSettled()`

返回一个 Promise，当所有给定的 Promise 都已完成（不论是成功还是失败）时，会返回一个包含每个 Promise 的结果的数组。

```javascript
const promises = [
  Promise.resolve(1),
  Promise.reject('error'),
  Promise.resolve(3)
];

Promise.allSettled(promises).then(results => {
  console.log(results);
  // 输出 [{ status: 'fulfilled', value: 1 }, { status: 'rejected', reason: 'error' }, { status: 'fulfilled', value: 3 }]
});
```

## #4 == 和 === 的区别

JavaScript 提供三种不同的值比较运算：
- === 严格相等（三个等号）
- == 宽松相等（两个等号）
- Object.is()

`==`叫做相等运算符，`===`叫做严格运算符。

### 规则

1. `==`：先隐式类型转换，再判断值是否相等

2. `===`：直接判断 类型 + 值 是否相等

3. `==`表示只要值相等即可为真，而`===`则要求不仅值相等，而且也要求类型相同。

### `==`

```javascript
5 == '5'                          // true，因为字符串 '5' 被转换为数字 5
'' == '0'                         // false
0 == ''                           // true
0 == '0'                          // true
false == 'false'                  // false
false == '0'                      // true
false == undefined                // false
false == null                     // false
null == undefined                 // true
' \t\r\n ' == 0                   // true
```
嗯,很奇妙的`==`，给我带来了一些反直觉的结果

### `===`

```javascript
console.log(1 === "1");           //false, 类型不同
console.log(true === 1);          //false, 类型不同
console.log(null === undefined);  // false，因为类型不同
```
nice，和符合我们直觉的结果

所以说：一般推荐在 JavaScript 中优先使用 `===`，以避免潜在的错误，而且很符合我们的直觉何乐而不为呢？

### 补充 Object.is()

:::info Object.is()
Object.is() 是一个用于比较两个值是否相同的方法，它在某些情况下比 === 更准确。以下是 Object.is() 的主要特点和用法：

```javascript
Object.is(value1, value2);
```
特点：
1. 类型和值完全相等：Object.is() 会考虑值的类型，并且只有在两个值相等时才返回 true。
2. 特殊情况
  - `NaN`被视为相等
    ```javascript
    console.log(Object.is(NaN, NaN)) // true 注意： === 是false
    ```
  - `+0` 和 `-0`被视为不想等
    ```javascript
    console.log(Object.is(+0, -0)); //false 注意： === 是相等
    ```

与 `===` 的比较
Object.is() 更严格，它处理一些 `===` 不处理的特殊情况。
对于一般的比较，=== 更加常用，但在需要处理 NaN 和 +0/-0 的情况下，Object.is() 更加可靠。

当需要精确比较对象、数组或者处理特殊值时，使用 Object.is() 是一个很好的选择。

总的来说，Object.is() 提供了一种更精确的方式来比较值，特别是在处理 JavaScript 中的一些特殊情况时。

:::

> 参考：
>
> [相等比较和相同 MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness)

